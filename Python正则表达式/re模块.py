# 记住字符转义符号 'ABC\\-001'代表'ABC\-001'
# 因此我们可以用r前缀 不考虑转义问题 s=r'ABC\-001'

# 功能一：匹配
import re
print(re.match(r'^\d{3}\-\d{3,8}$', '010-12345'))
# match方法判断是否匹配 如果匹配成功返回一个Match对象 否则返回None
test='用户输入的字符串'
if re.match(r'正则表达式',test):
    print('OK')
else:
    print('failed')
    

# 功能二:切分
# 正常的话可以用split方法 但有缺陷 比如说我们用单空格切分时 就无法识别多空格
# 正则表达式切割比他厉害
print(re.split(r'\s+','a b  c'))
print(re.split(r'[\s\,]+','a,b, c  d'))
print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))
# !!用户输入了一组标签 下次记得用正则表达式来把不规范的输入转化成正确的数组


# 功能三:分组 从匹配的字符串中提取子串 ()表示分组
print(re.match(r'^(\d{3})-(\d{3,8})$', '010-12345'))
m=re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
# 匹配器对象
print(m.group(0))
print(m.group(1))
print(m.group(2))
# 如果正则表达式定义了组 就可以在Match对象上用group方法提取出子串
# group(0)永远是子串 group(1) group(1)....
# 凶残例子 用正则识别合法的时间。
t='19:05:30'
m=re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(m)


# 功能三:贪婪匹配 默认是贪婪匹配 就是匹配尽可能多的字符.
# 比如
print(re.match(r'^(\d+)(0*)$','102300').groups())
# \d+ 贪婪匹配 直接把后面0全都匹配了 所以0*只能匹配空字符串了
#用？阻止非贪婪匹配 也就是尽可能少匹配 才能把后面的0匹配出来 
print(re.match(r'^(\d+?)(0*)$', '102300').groups())


# 原理: 当我们Python使用正则表达式时 re模块内部会干两件事:
#    1.编译正则表达式 如果正则表达式字符串本身不合法 会报错
#    2.用编译后的正则表达式去匹配字符串

# 如果一个正则表达式重复使用几千次 出于效率的考虑我们可以预编译该正则表达式
# 编译
re_telephone=re.compile(r'^(\d{3})-(\d{3,8})$')
print(re_telephone.match('010-12345').groups())
